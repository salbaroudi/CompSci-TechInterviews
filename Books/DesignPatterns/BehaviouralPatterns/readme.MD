## Behavioural Patterns

### Iterator:

With an Iterator, we separate data structure traversal code from the data structure class itself. This allows us to traverse elements of a collection, without exposing the underlying representation of the collection itself (privatized ?).


#### Actors:

1) Iterator Interface: Declares basic methods (getNext() and hasMore()), that all iterators will implement.

2) Collection Interface: Only declares the createIterator() method, for concrete classes to implement.

3) Concrete Collection: Stores nodes for collection. Impleements createIterator() and uses privacy to restrict non-essential details to client, or other external agents.

4) Concrete Iterator: Implements Interface. Is specifically generated by the Concrete Collection. 

5) Client: Will Call Concrete Collection, and operate the Concrete Iterator. 


#### Key Implementation Details:

The use of interfaces for the Iterator and Colleciton class decouples the Client from particular Collection/Iterator classes. In particular, we have two interfaces - the Aggregate and Iterator, each of which is implemented by concrete classes below. In particular, the traversal details and data storage details are effectively separated. We can also have multiple ConcreteIterators, to support different traversal methods.

Despite this separation, there is crucial overlap of constructor for the Iterator. The ConcreteAggregate class **must** construct and pass an iterator to the client. This is to protect the internals of the Concrete Aggregate (CA). The iterator will traverse the CA, but only reveal certain information for each of the nodes in the CA. See the LogisticsDemo example  


#### Benefits and Drawbacks:

+ Any number of iterators can be run at once - as they maintain there own position/state, and do not mutate the data-structure

+ Easy to create new Iterator Sub-classes, for alternative schemes. Client is decoupled from this.

+ Separation of Collection and Traversal code is clean (Single Responsibility Principle).

- Iterators may be overkill, or not very efficient compared to imperative traversal methods.


### Chain of Responsibility:

This Design Pattern focuses on request handling, splitting up different operations on a request into discrete handlers. These are chained together, and can implement different behaviours (only one handles request, all modify the request as middle-ware, etc). 

A great practical example of this in action is Express.js's Middleware JS events, for Node.js.

#### Actors:

1) Handler Interface: Defines setNext(Handler), handle(request) and any other basic request that 

2) Base Handler Class: Implements Interface, also stores a field for another Handler Object.

3) (Optional) Concrete Handler: Can have an extra sub-class of handlers, to have different types, etc.


#### Key Implementation Details:

CoR works by transforming particular behaviours (that work on requests) into stand-alone objects (called *handlers*). In addition to implementing specific behaviours, such handlers have pointers to other handlers, or may terminate depending on the state of the request.


#### Benefits and Drawbacks:

+ As we can chain sets of self-contained handlers in any order (at config time), we can tailor particularly custom request piping solutions. Easy to modify our chain, if new requirements arise.

+ Reduced coupling (between handlers) - they don't need to know what handler is before/after. Compartmentalized code.

+ We can also contorl the order of request handling.

### Template Method:

A Design Pattern that allows us to customize a step-wise algorithm by using abtract classes that can be overriden. The algorithm breaks down the Algorithm into a series of steps - some of which are abstract while others implemented. Programmer can control the flexibility of implementation, via sub-class inheritence of the abstract class.

#### Actors:

1) Abstract Class: Contains interface for abstract methods (to be implemented by sub-classes), and implementations for fixed methods (parts of Algorithm that cannot be customized).

2) Concrete Classes: inherits the abstract class, and implements abstract methods accordingly.

3) Client: Will call Concrete Class, and run specific instance of algorithm.

#### Key Implementation Details:

The Abstract class gives us a fine degree-of-control, on what can and cannot be varied in our algorithm. That is all.

#### Benefits and Drawbacks:



